/**
	GOAP NPC: Goal-Oriented Action Planning for Non-Player Characters
	Copyright � 2022 Narratech Laboratories

	Authors: Diego Romero-Hombrebueno Santos, Mario S�nchez Blanco, Jos� Manuel Sierra Ramos, Daniel Gil Aguilar and Federico Peinado
	Website: https://narratech.com/project/goap-npc/
 */
#include "GOAPController.h"
#include "Navigation/CrowdFollowingComponent.h"

#define BToS(b) b ? TEXT("true") : TEXT("false")

AGOAPController::AGOAPController(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer.SetDefaultSubobjectClass<UCrowdFollowingComponent>(TEXT("PathFollowingComponent")))
{
}

void AGOAPController::BeginPlay()
{
	// Loads actions.
	for (auto i = 0; i < actions.Num(); ++i)
	{
		if (actions[i] != NULL)
		{
			FString aux = actions[i].GetDefaultObject()->GetName();
			auxActions.Push(actions[i].GetDefaultObject());
		}
	}

	// Loads Current World.
	for (FAtom atom : currentWorld)
		wsCurrentWorld.addAtom(atom.name, atom.value);

	// Loads Desired World.
	for (auto atom : desiredWorld)
		wsDesiredWorld.addAtom(atom.Key.name, atom.Key.value);

	// Loads actions' preconditions and effects.
	for (UGOAPAction* a : auxActions)
		a->create_P_E();

	// Loads Planner.
	planner = new GOAPPlanner(&wsCurrentWorld, &wsDesiredWorld, auxActions);
	planner->setMaxDepth(maxDepth);

	// Error messages.
	if (auxActions.Num() == 0)
		UE_LOG(LogTemp, Warning, TEXT("Actions not found in GOAPController."));

	if (wsCurrentWorld.isEmpty())
		UE_LOG(LogTemp, Warning, TEXT("Undefined Current World in GOAPController."));

	if (wsDesiredWorld.isEmpty())
		UE_LOG(LogTemp, Warning, TEXT("Undefined Desired World in GOAPController.")); // This is normal in the first execution, isn�t it?

	Super::BeginPlay();
}

void AGOAPController::OnPossess(APawn* pawn)
{
	Super::OnPossess(pawn);
}

void AGOAPController::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);
}

bool AGOAPController::executeGOAP()
{
	if (generatePlan())
	{
		if (plan.Num() > 0)
		{
			// Gets next action to perform.
			UGOAPAction* aux = plan[plan.Num() - 1];

			// Performs an action and when it's done its effects are applied, changing the current world state.
			if (aux->doAction(GetPawn()))
			{
				wsCurrentWorld.joinWorldState(aux->getEffects());
			}

			return true;
		}
	}

	return false;
}

bool AGOAPController::generatePlan()
{
	if (auxActions.Num() > 0 && !wsCurrentWorld.isEmpty() && !wsDesiredWorld.isEmpty())
	{
		// Creates the cheapest plan of actions.
		plan = planner->generatePlan(GetPawn());
		if (debug && GEngine)
			debugInfo();

		return true;
	}

	return false;
}

TArray<UGOAPAction*> AGOAPController::getPlan()
{
	return plan;
}

void AGOAPController::setGoal(const TArray<FAtom>& newGoal)
{
	wsDesiredWorld.cleanAtoms();
	updateGoal(newGoal);
}

void AGOAPController::updateGoal(const TArray<FAtom>& atoms)
{
	for (FAtom atom : atoms)
		wsDesiredWorld.addAtom(atom.name, atom.value);
}

void AGOAPController::setCurrentWorld(const TArray<FAtom>& newCurrentWorld)
{
	wsCurrentWorld.cleanAtoms();
	updateCurrentWorld(newCurrentWorld);
}

void AGOAPController::updateCurrentWorld(const TArray<FAtom>& atoms)
{
	for (FAtom atom : atoms)
		wsCurrentWorld.addAtom(atom.name, atom.value);
}

TArray<FAtom> AGOAPController::getCurrentWorldStateAtoms()
{
	TArray<FAtom> worldStateAtoms;
	for (auto atoms : wsCurrentWorld.getAtoms())
	{
		worldStateAtoms.Add({ atoms.Key, atoms.Value });
	}

	return worldStateAtoms;
}

TArray<FAtom> AGOAPController::getDesiredWorldStateAtoms()
{
	TArray<FAtom> worldStateAtoms;
	for (auto atoms : wsDesiredWorld.getAtoms())
	{
		worldStateAtoms.Add({ atoms.Key, atoms.Value });
	}

	return worldStateAtoms;
}

void AGOAPController::AddActionToGOAPPlanner(UGOAPAction* Action)
{
	planner->addAction(Action);
}

void AGOAPController::RemoveActionFromGOAPPlanner(UGOAPAction* Action)
{
	planner->removeAction(Action);
}

void AGOAPController::AddKeyedAtoms(FAtom Goal, TArray<FAtom> Atoms)
{
	updateCurrentWorld(Atoms);
	// store the atoms
	KeyedAtoms.FindOrAdd(Goal).Append(Atoms);
}

void AGOAPController::RemoveKeyedActionFromGOAPPlanner(FAtom Goal)
{
	for (UGOAPAction* Action : planner->getKeyedActions(Goal.name))
	{
		SavingFromGarbo.Remove(Action);
	}

	planner->removedKeyedActions(Goal.name);
	// also remove the atoms from current world

	TArray<FAtom> Atoms = KeyedAtoms[Goal];

	for (FAtom Atom : Atoms)
	{
		wsCurrentWorld.removeAtom(Atom.name);
	}

	KeyedAtoms.Remove(Goal);
}

void AGOAPController::debugInfo()
{
	FString name = GetPawn()->GetName();

	GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT("Plan generated by: " + name), false);
	if (controller)
		GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT("controller: " + this->GetName()), false);
	// GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT("\n"), false);

	for (int i = 0; i < plan.Num(); i++)
	{
		if (i != 0)
			GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Orange, TEXT("--->"), false);
		FString action = plan[i]->GetName();
		GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Orange, TEXT("" + action), false);
	}

	GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Orange, TEXT("\n"), false);
}
